# 网页版3D粒子动态圣诞树项目开发文档

## 🎄 项目概述
本项目旨在创建一个基于Web技术的3D粒子动态圣诞树视觉艺术效果。核心特征为：以粉色系粒子构成树体，夹杂淡黄色调粒子作为点缀，树底部配以周期性扩散的发光波纹。最终通过一个URL链接即可在浏览器中观看和交互。

---

## 🛠️ 技术栈 (Tech Stack)

### 核心框架与库
| 技术 | 版本/选择 | 用途说明 |
| :--- | :--- | :--- |
| **Three.js** | r128+ | 项目基石，用于创建和管理所有3D对象、场景、相机、渲染及动画循环。 |
| **原生WebGL** | - | Three.js底层所依赖的浏览器图形API。 |
| **GLSL** | - | 用于编写自定义顶点/片元着色器，实现粒子发光、颜色渐变、波纹等高级特效。 |

### 辅助工具库
| 技术 | 用途 |
| :--- | :--- |
| **dat.GUI** | 在屏幕上生成实时控制面板，用于调试粒子数量、颜色、速度等参数，极大提升开发效率。 |
| **OrbitControls** (Three.js内置) | 为场景添加鼠标拖拽旋转、滚轮缩放等交互控制。 |

### 开发与部署环境
| 环节 | 技术/工具 |
| :--- | :--- |
| **开发环境** | VS Code（推荐）、现代浏览器（Chrome/Edge/Firefox用于调试） |
| **本地服务器** | VS Code Live Server 扩展 或 `npm serve` |
| **版本控制** | Git |
| **部署平台** | GitHub Pages, Vercel, Netlify 等静态网站托管服务。 |

---

## ⚙️ 实现方式 (Implementation Approach)

### 1. 项目结构与初始化
- **结构**：创建标准的静态网站目录（`index.html`, `js/main.js`, `css/style.css`, `shaders/`）。
- **初始化**：在HTML中引入Three.js等库，在`main.js`中初始化场景(`Scene`)、透视相机(`PerspectiveCamera`)、WebGL渲染器(`WebGLRenderer`)，并将渲染器的画布(`canvas`)插入页面。

### 2. 圣诞树粒子系统实现
- **几何体(Geometry)**：使用 `THREE.BufferGeometry`。
- **数据计算**：通过JavaScript函数生成粒子坐标，形成3D圣诞树（圆锥形）形状。
    ```javascript
    // 核心思路：分层（沿Y轴）计算
    for(let layer = 0; layer < totalLayers; layer++){
        let y = ...; // 当前层高度
        let radius = ...; // 当前层半径（越往上越小）
        for(let i = 0; i < particlesPerLayer; i++){
            let angle = Math.random() * Math.PI * 2;
            let x = Math.cos(angle) * radius * Math.random();
            let z = Math.sin(angle) * radius * Math.random();
            // 将(x,y,z)填入positions数组
            // 根据概率，将颜色填入colors数组（粉色或淡黄）
        }
    }
    ```
- **材质(Material)**：使用 `THREE.PointsMaterial` 并启用顶点颜色(`vertexColors: true`)，或使用自定义的 `THREE.ShaderMaterial` 以实现更动态的发光效果。
- **创建系统**：使用 `THREE.Points(geometry, material)` 创建粒子系统并加入场景。

### 3. 底部发光波纹实现
- **几何体**：一个 `THREE.CircleGeometry` 平面，位于树底。
- **材质**：核心使用自定义的 `THREE.ShaderMaterial`。
    - **顶点着色器**：主要负责传递位置和纹理坐标。
    - **片元着色器**：计算波纹效果。
        ```glsl
        // 核心算法（伪代码）
        float distanceToCenter = length(vUv - vec2(0.5));
        // 1. 创建波纹：利用正弦函数和距离、时间的关系
        float wave = sin(distanceToCenter * 10.0 - uTime * 2.0) * 0.5 + 0.5;
        // 2. 创建衰减：边缘透明
        float fade = 1.0 - smoothstep(0.0, 0.5, distanceToCenter);
        // 3. 合成：将波纹、衰减、粉色基础色结合，并输出带有透明度的颜色
        gl_FragColor = vec4(pinkColor * wave * fade, fade * wave);
        ```
- **动画**：在动画循环中更新传入着色器的统一时间变量(`uTime`)，驱动波纹运动。

### 4. 动态效果与交互
- **动画循环**：使用 `requestAnimationFrame` 创建循环，在每一帧中：
    1.  更新粒子位置（实现缓慢的上下浮动）。
    2.  更新波纹着色器的`uTime`。
    3.  更新`OrbitControls`。
    4.  执行渲染`renderer.render(scene, camera)`。
- **交互**：实例化 `OrbitControls`，并将其与相机和渲染器的DOM元素绑定。

### 5. 调试与优化
- **调试**：使用`dat.GUI`快速创建控制界面，关联到粒子数量、颜色、速度等变量。
- **优化**：使用Chrome DevTools的Performance面板分析帧率。采用Three.js的常见优化手段，如：
    - 合并几何体，减少绘制调用。
    - 在移动端或性能不佳时，动态减少粒子数量(`particleCount`)。

---

## 🎯 实现目标 (Implementation Goals)

### 1. 视觉与功能目标
- **粒子树**：生成一棵由**5000 - 20000个**独立发光粒子构成的3D圣诞树。
- **色彩方案**：
    - **主色调**：粉色系。示例RGB值：`[1.00, 0.71, 0.76]` (浅粉), `[0.98, 0.52, 0.63]` (中粉)。
    - **点缀色**：淡黄色。示例RGB值：`[1.00, 0.95, 0.80]`。占比约5%-10%，随机分布。
- **波纹效果**：树底有**至少2层**周期性向外扩散的半透明粉色发光波纹，与树体色调融合。
- **交互**：支持鼠标**左键拖拽旋转**视角、**滚轮缩放**。

### 2. 性能目标
- 在主流桌面浏览器的1080p分辨率下，保持**≥ 50 FPS**的流畅动画。
- 实现响应式设计，能自适应不同尺寸的屏幕（从手机到桌面显示器）。

---

## 🎨 目标样式描述 (Visual Style Description)

整个场景运行在一个**深邃的暗粉紫色背景**（如 `#1a0b1a`）中，营造出梦幻、静谧的数字艺术氛围。

1.  **树体**：由成千上万个微小的发光粒子组成。粒子并非静止，而是在其初始位置附近**缓慢地、随机地上下浮动**，仿佛在轻盈呼吸。整体树形可能以极慢的速度自动旋转，方便展示全貌。
2.  **色彩细节**：**绝大多数粒子为粉色**，但通过精心的随机化，呈现出从柔和的桃粉到较深的玫粉的丰富层次。**淡黄色粒子**作为点缀，如同散落在树上的星光或特殊装饰，其亮度可以设置得略高，使其更为醒目。
3.  **底部特效**：在树的根部，**一圈圈半透明的粉色光晕**如同水面的涟漪，持续而优雅地从中心向外扩散、变淡、消失。波纹带有“发光”效果，边缘柔和，与静态的树根部分形成“静中有动”的视觉对比，增强了场景的立体感和神秘感。
4.  **交互反馈**：用户拖拽视图时，交互流畅，光影关系实时变化。可通过弹出的调试面板实时调整视觉参数（如整体色调、粒子速度、波纹频率），使项目本身也成为一个有趣的视觉实验工具。

---

## 🚀 快速开始模板

创建一个 `index.html` 文件，复制以下代码，即可在浏览器中看到基础的三维场景和粒子。

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D粒子动态圣诞树</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #canvas-container { width: 100vw; height: 100vh; }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ffccf5;
            font-family: monospace;
            font-size: 14px;
            z-index: 100;
            background-color: rgba(26, 11, 26, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="info">正在加载3D场景...</div>

    <!-- 引入Three.js核心库及控制器 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <!-- 后续可引入dat.GUI等库 -->

    <script>
        // ------ 1. 初始化基础场景 ------
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 8); // 调整相机初始位置

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x1a0b1a, 1); // 设置暗粉紫色背景
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // ------ 2. 添加交互控制 ------
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // 启用阻尼，使控制更平滑
        controls.dampingFactor = 0.05;

        // ------ 3. 创建测试粒子（此处将替换为圣诞树）------
        const particleCount = 1500;
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);

        const pinkColor = new THREE.Color(0xffb6c1); // 基础粉色
        const yellowColor = new THREE.Color(0xfff4c1); // 淡黄色

        for(let i = 0; i < particleCount; i++) {
            // 随机位置（临时）
            positions[i*3] = (Math.random() - 0.5) * 10;
            positions[i*3+1] = (Math.random() - 0.5) * 10;
            positions[i*3+2] = (Math.random() - 0.5) * 10;

            // 随机分配颜色（90%粉，10%黄）
            const useYellow = Math.random() < 0.1;
            const color = useYellow ? yellowColor : pinkColor;

            colors[i*3] = color.r;
            colors[i*3+1] = color.g;
            colors[i*3+2] = color.b;
        }

        const particlesGeometry = new THREE.BufferGeometry();
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.08,
            vertexColors: true, // 启用顶点颜色
            transparent: true,
            // depthWrite: false // 透明物体渲染时可考虑
        });

        const testParticles = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(testParticles);

        // ------ 4. 简单灯光（如需）------
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // 柔和的环境光
        scene.add(ambientLight);

        // ------ 5. 动画循环 ------
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // 更新控制器

            // 示例：让粒子缓慢旋转
            testParticles.rotation.y += 0.002;

            renderer.render(scene, camera);
        }
        animate();

        // ------ 6. 窗口自适应 ------
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 更新界面提示
        document.getElementById('info').innerHTML = '基础场景已就绪。<br>鼠标：左键拖拽旋转，滚轮缩放。<br>下一步：替换为圣诞树形 & 添加波纹。';
    </script>
</body>
</html>
```

---

## 📂 后续开发步骤建议

1.  **替换粒子形状**：将上述模板中创建随机粒子(`testParticles`)的代码，替换为根据 **“实现方式-2”** 中描述的算法生成的圣诞树形状粒子。
2.  **创建波纹对象**：在场景中添加一个圆形平面，并为其创建和应用自定义的着色器材质（参考 **“实现方式-3”**）。
3.  **引入dat.GUI**：添加调试面板，方便实时调整参数。
4.  **优化与测试**：在不同设备浏览器上进行测试，使用开发工具分析性能，并做相应优化。
5.  **部署**：将最终项目文件（HTML, JS, CSS, 资源）推送至GitHub仓库，并开启GitHub Pages功能，或部署到Vercel/Netlify。

**祝你开发顺利！** 如果在实现树形算法或编写着色器等具体环节遇到问题，可以随时就具体代码进行提问。

# 3D粒子圣诞树：视觉与动态详细规范

## 🌲 圣诞树形状的精确描述

### 1. 整体几何形状
圣诞树的整体轮廓基于一个**直立圆锥体**，但具有更丰富的自然细节层次。

*   **基础圆锥参数**：
    *   **高度**：在3D场景中，树的高度可标准化为 `10` 个单位。
    *   **底部半径**：树冠最宽处的半径约为高度的 `1/3`，即约 `3.3` 个单位。
    *   **顶部**：圆锥顶端为一个尖锐的顶点，可放置一颗特殊的“星”粒子。

*   **分层结构**：
    树体在垂直方向上应分为 **5-7个明显的层级**，模拟松树的轮生枝条。每一层都像一个小型的、略微下垂的碟片或伞盖。
    *   **层高**：越靠近底部，层与层之间的**间隔越大**；越靠近顶部，间隔越密集。
    *   **层半径**：从底部到顶部，每一层的**半径依次递减**，形成优美的锥形轮廓。中间层的半径可以略微向外凸出，使树形更饱满。

### 2. 粒子分布与细节
粒子是构成树的基本像素，其分布需遵循自然规律。

*   **密度分布**：
    *   **内部核心**：树干中心轴线附近，粒子分布**非常密集**，形成不透明的树芯，颜色可稍深。
    *   **外部枝叶**：从核心到每层的边缘，粒子密度**逐渐降低**，在边缘形成稀疏、朦胧的“毛刺感”，模仿松针的疏落。

*   **粒子类型与颜色**：
    | 粒子类型 | 占比 | 颜色描述 (RGB示例) | 分布规则 |
    | :--- | :--- | :--- | :--- |
    | **主色调粒子** | ~85% | **粉色系谱**：从较深的 `[0.95, 0.50, 0.60]` 到柔和的 `[1.00, 0.80, 0.85]` 之间随机。 | 构成树的主体，均匀分布于各层。 |
    | **高亮点粒子** | ~10% | **亮粉色/淡紫色**：`[1.00, 0.90, 0.95]` 或 `[0.95, 0.75, 1.00]`，亮度更高。 | 随机分布，但在每层边缘和顶部可稍多，模拟反光。 |
    | **装饰点缀粒子** | ~5% | **淡黄色**：`[1.00, 0.95, 0.80]`，像温暖的小灯。 | **非随机**。应刻意将其布置在：1) 每层枝条的末端；2) 形成螺旋线缠绕树体；3) 在顶部聚集形成“星星”。 |

*   **树干**：
    在树底中心，一个非常细长的、高度约为树高 `1/5` 的暗色圆柱体区域，粒子稀疏或使用深棕色 (`[0.3, 0.2, 0.15]`) 粒子表示。

## 💨 风吹波动方式的动力学描述

波动效果不应是粒子无规则的乱动，而应模拟一阵风穿过松针时产生的**连贯的、波浪形的柔韧响应**。

### 1. 波动原理
将整棵树视为一个柔软的、顶端固定的锥形体。当风（视为一个水平方向的力）吹过时，树会从顶部开始，像波浪一样将形变向下传递。

### 2. 具体实现算法（伪代码逻辑）

波动可以通过在动画循环中**持续修改每个粒子的水平位置（X和Z坐标）**来实现。其核心是以下几个因素的叠加：

```javascript
// 核心波动函数示例
function calculateWindOffset(particle, time) {
    // 1. 基础波形：一个沿Y轴变化的水平力
    let waveFrequency = 0.5; // 波浪的紧密程度
    let waveSpeed = 1.0; // 波浪运动的速度
    let windStrength = 0.3; // 风的整体强度
    
    // 粒子在树中的“高度比”（0在底部，1在顶部）
    let heightRatio = particle.originalY / totalTreeHeight;
    
    // 2. 关键：相位差。顶部的粒子先动，底部的后动。
    // 通过给不同高度的粒子加上不同的相位延迟来实现。
    let phaseDelay = heightRatio * Math.PI * 2; 
    
    // 3. 计算基础波形位移
    let baseOffset = Math.sin(heightRatio * waveFrequency * Math.PI * 2 + time * waveSpeed + phaseDelay);
    
    // 4. 幅度衰减：树根固定不动，所以越往下摆动幅度越小
    let amplitudeAttenuation = heightRatio; // 或 heightRatio的平方以获得更自然的衰减
    
    // 5. 随机性：给每个粒子一点独立的微小随机运动，避免过于机械
    let individualSway = particle.noiseSeed * 0.1 * Math.sin(time * 0.7 + particle.noiseSeed);
    
    // 6. 风的间歇性：风是一阵一阵的，可以引入一个随时间缓慢变化的“风强因子”
    let windPulse = 1.0 + 0.3 * Math.sin(time * 0.1); // 一个缓慢的脉冲
    
    // 7. 最终位移
    let totalOffsetX = (baseOffset * amplitudeAttenuation * windStrength + individualSway) * windPulse;
    // Z方向可以用另一个有相位差的sin函数，让摆动更立体
    let totalOffsetZ = Math.cos(heightRatio * waveFrequency * Math.PI * 2 + time * waveSpeed * 0.9 + phaseDelay) * amplitudeAttenuation * windStrength * 0.7 * windPulse;
    
    return { offsetX: totalOffsetX, offsetZ: totalOffsetZ };
}
```

### 3. 波动视觉特征总结

*   **方向**：主要摆动方向与风向垂直。如果风是X方向，树主要会在X和Z方向摆动。
*   **波浪传递**：一个明显的弯曲波形**从树顶向树根传递**。顶部的摆动幅度最大，随着波浪向下传递，幅度逐渐减小，到树根处几乎静止。
*   **滞后与柔韧**：由于相位延迟，中间层的粒子运动轨迹会**略微滞后于**顶层的粒子，产生一种柔韧的“跟随”效果。
*   **随机细节**：在整体波形之上，每个粒子有极其微小的、独立的颤动，模拟单根松针的抖动。
*   **风的节奏**：风的强度 (`windStrength`) 本身可以缓慢地周期性变化，模拟阵风的强弱，使树的运动更有节奏感，而非单调摆动。

## 🎨 与底部波纹的对比与融合

| 特性 | **风吹树波动** | **底部发光波纹** |
| :--- | :--- | :--- |
| **驱动源** | 模拟**物理力**（风）的作用。 | 模拟**能量扩散**（光、波）。 |
| **运动维度** | 主要在**水平方向**（XZ平面）的位移。 | 在**2D平面**上的径向（向外）扩张。 |
| **视觉形态** | **整体形变**，粒子间运动连续、相关，形成“体”的波动。 | **同心圆环**，从中心诞生并向外消散，是“面”的效应。 |
| **与树的关系** | 是**树本体**的动态。 | 是树**投射在环境**（地面/空间）中的效应，属于场景氛围。 |
| **颜色** | 使用粒子本身的颜色（粉/黄）运动。 | 使用固定的、半透明的粉色调光晕。 |

**融合效果**：静止时，底部宁静的波纹衬托着发光的树。当“风”吹起时，树体开始优雅地波浪形摆动，而底部的波纹依然保持自己独立的、缓慢的扩散节奏，两者一动一静、一实一虚，共同构成一个完整而富有生命力的数字艺术场景。

这个详细的描述为你提供了将概念转化为代码所需的具体参数和算法思路。接下来，你可以开始编写树形粒子的位置生成函数和实现风波动画的着色器或JavaScript更新逻辑了。